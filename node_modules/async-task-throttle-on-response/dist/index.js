"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var driftless_1 = require("driftless");
var AsyncTaskThrottle = /** @class */ (function () {
    function AsyncTaskThrottle(task, rateLimitCount, rateLimitDuration, queueLength) {
        this._queue = [];
        this._task = task;
        this._workerCount = rateLimitCount || 1;
        this._rateLimitDuration = rateLimitDuration || 5000;
        this._queueLength = queueLength || Infinity;
        this._workingCount = 0;
        this._workingCountProcessing = 0;
    }
    AsyncTaskThrottle.create = function (task, rateLimitCount, rateLimitDuration, max) {
        var throttle = new AsyncTaskThrottle(task, rateLimitCount, rateLimitDuration, max);
        function asyncTask() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return new Promise(function (resolve, reject) {
                throttle.push({
                    args: args,
                    reject: reject,
                    resolve: resolve,
                });
            });
        }
        return asyncTask;
    };
    AsyncTaskThrottle.prototype.getWorkingCount = function () {
        return this._workingCount;
    };
    AsyncTaskThrottle.prototype.create = function () {
        var _this = this;
        var asyncTask = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return new Promise(function (resolve, reject) {
                _this.push({
                    args: args,
                    reject: reject,
                    resolve: resolve,
                });
            });
        };
        return asyncTask;
    };
    AsyncTaskThrottle.prototype.push = function (options) {
        if (this._queue.length < this._queueLength) {
            this._queue.push(options);
            this.work();
        }
        else {
            options.reject(new Error('It is exceeding load.'));
        }
    };
    AsyncTaskThrottle.prototype.work = function () {
        var _this = this;
        if (this._workingCount < this._workerCount) {
            var options_1 = this._queue.shift();
            if (options_1) {
                this._workingCount++;
                this._workingCountProcessing++;
                this._task.apply(this, options_1.args).then(function (value) {
                    options_1.resolve(value);
                })
                    .catch(function (error) {
                    options_1.reject(error);
                })
                    .then(function () {
                    _this._workingCountProcessing--;
                    if (_this._workingCountProcessing === 0) {
                        driftless_1.setDriftlessTimeout(function () {
                            _this._workingCount = 0;
                            var length = Math.min(_this._workerCount, _this._queue.length);
                            for (var index = 0; index < length; index++) {
                                _this.work();
                            }
                        }, _this._rateLimitDuration);
                    }
                });
            }
        }
    };
    return AsyncTaskThrottle;
}());
exports.default = AsyncTaskThrottle;
